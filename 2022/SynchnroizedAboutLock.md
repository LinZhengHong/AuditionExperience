## Synchnorized锁升级过程

#### 偏向锁——>轻量锁——>重量级锁

提及过线程安全,多多少少会使用过synchnorized这个关键字,在Java同步代码块中,synchnorized的使用方式无非有三种:

```tex
1.修饰实例方法
2.修饰静态方法
3.修饰代码块
```

无论是对代码块进行加锁还是对一个方法进行加锁，实际上，都是对**对象进行加锁**

#### 锁对象

如上面所说,锁实际上是对对象加锁,那么被加了锁的对象就被称为锁对象.在Java中,任何一个对象都能成为锁对象.那么问题来了,**JVM虚拟机是怎么知道这个对象是锁对象尼?**

```tex
Java对象在内存中的存储结构主要组成部分:
1.对象头
2.实例数据
3.填充数据
```

简单结构如下:

| 长度     | 内容                   | 说明                       |
| -------- | ---------------------- | -------------------------- |
| 32/64bit | Mark Word              | hashCode,GC分代年龄,锁信息 |
| 32/64bit | Class Metadata Address | 指向对象类型数据的指针     |
| 32/64bit | Array Length           | 数组的长度(当对象为数组)   |

从上面结构可以看出对象中关于锁的信息是存在MarkWord里的.

```
LockByObject lockObject = new LockByObject(); 创建一个锁对象
```

当我们创建一个对象LockObject时,该对象的部分Markword关键数据如下:

| Bit fields | 是否偏向锁 | 锁标识位 |
| ---------- | ---------- | -------- |
| hash       | 0          | 01       |

从图中可以看出,偏向锁的标志位是“01”,状态是“0”(“1是表示被加上偏向锁”),表示**该对象还没有被加上偏向锁**.该对象创建出来的那一刻,就有了偏向锁的标志位,这也说明了所有对象都是可偏向的,但所有对象的状态都为“0”,也同时说明了所有被创建的对象的偏向锁并没有生效.

#### 偏向锁

```tex
LockByObject lockObject = new LockByObject(); 创建一个锁对象
synchnorized(lockObject){
//代码
}
```

不过,当线程执行到临界区(critical section)时,此时会利用CAS(Compare and Swap)操作,将线程ID插入到Markword中,同时修改偏向锁的状态.

<!--所谓临界区,就是只允许一个线程进去执行操作的区域,即同步代码块.CAS是一个原子性操作-->

此时的Mark word的结构信息如下:

| bit fields       |       | 是否偏向锁 | 锁标志位 |
| ---------------- | ----- | ---------- | -------- |
| ThreadID(线程ID) | Epoch | 1          | 01       |

此时偏向锁的状态位“1”,**说明对象偏向锁生效了,同时可以看到哪个线程获得了该对象的锁**

#### 那么,什么是偏向锁

偏向锁是jdk1.6引入的一项锁优化,其中的“偏”是偏心的偏.这个锁会偏向于第一个获得它的线程,在接下来的执行过程,假如该锁没有被其他线程所获取,没有其他线程来竞争该锁,那么持有偏向锁的线程将永远不需要进行同步操作.

也就是在此线程之后的执行过程中,如果再次进入或者退出同一段同步块代码,并不再需要去进行**加锁**或者**解锁**操作,而是会做以下的步骤:

```tex
1.Load-and-test,也就是简单判断下当前线程Id是否与Markword当中的线程id是否一致.
2.如果一致,则说明此线程已经成功获得了锁,继续执行下面的代码
3.如果不一致,则要检查一下对象是否还是可偏向,即"是否偏向锁"标志位的值
4.如果还未偏向,则利用CAS操作来竞争锁,即是第一次锁时的操作
```

如果此对象已经偏向了,并且不是偏向自己,则说明存在了**竞争**.此时可能就要根据另外线程的情况,可能是重新偏向,也有可能是做偏向撤销,但大部分情况下就是升级成**轻量级锁**了.

可以看出,偏向锁是针对于一个线程而言的,线程获得锁之后就不会再有解锁等操作了,这样可以省略很多开销.假如有两个线程来竞争该锁的话,但大部分情况下就是升级成轻量级锁了.

##### 锁膨胀

刚才说了,当出现有两个线程来竞争锁的话,那么偏向锁就失效了,此时锁就会膨胀,升级为轻量级锁.这就是我们经常所说的**锁膨胀**.

##### 锁撤销

由于偏向锁失效了,那么接下来就得把这锁撤销,锁撤销的开销花费还是挺大的,其大概的过程如下:

```tex
1.在一个安全点停止拥有锁的线程
2.遍历线程栈,如果存在锁记录的话,需要修复锁记录和Markword,使其变成无锁状态.
3.唤醒当前线程,将当前锁升级成轻量级锁.
```

所以如果某些同步代码块大多数情况下都是有两个及以上的线程竞争的话,那么偏向锁就会是一种累赘,对于这种情况,我们可以一开始就把偏向锁这个功能给关闭.

#### 轻量级锁

锁撤销升级为轻量级锁之后,那么对象的Markword也会进行相应的变化.

下面先简单描述下锁撤销之后,升级为轻量级锁的过程:

```tex
1.线程在自己的栈桢中创建锁记录LockRecord
2.将锁对象的对象头中的MarkWord复制到线程的刚刚创建的锁记录中
3.将锁记录中的Owner指针指向锁对象
4.将锁对象的对象头的MarkWord替换为指向锁纪律的指针
```

之后Markword如下:

| bit fields           | 锁标志位 |
| -------------------- | -------- |
| 指向LockRecord的指针 | 00       |

注:锁标志位“00”表示轻量级锁

轻量级锁主要有两种

1.自旋锁

2.自适应自旋锁

##### 自旋锁

所谓自旋,就是指当有另外一个线程来竞争锁,这个线程会在原地等待,而不是将线程阻塞,直到那个获得锁的线程释放锁之后,这个线程就可以马上获得锁的.

注意,锁在原地循环的时候,是会消耗CPU的,就相当于在执行一个啥也没有的for循环.

所以,轻量级锁适用于那些同步代码块执行的很快的场景,这样线程原地等待很短很短的时间就能获得锁了.

##### 自旋锁的一些问题:

```tex
1.如果同步代码块执行的很慢,需要消耗大量的时间,那么这个时候,其他线程在原地等待空消耗c pu,这会让人很难受.
2.本来一个线程把锁释放之后,当前线程是能够获得锁的,但是假如这个时候有好几个线程都在竞争这个锁的话,那么有可能当前线程会获取不到锁,还得原地等待继续空循环消耗cpu,甚至有可能一致获取不到锁.

```

基于这个问题,我们必须给线程空循环设置一个次数,当线程超过了这个次数,我们就认为,继续使用自旋锁就不适合了,此时锁会再次膨胀,升级为重量级锁.

**默认情况下,自旋的次数为10次,用户可以通过-XX:PerBlockSpin来进行更改.**

##### 自适应自旋锁

所谓自适应自旋锁就是线程空循环等待的自旋次数并非是固定的,而是会动态根据实际情况来改变自旋等待的次数.

原理:

```tex
假如一个线程1刚刚成功获得一个锁,当它把锁释放了之后,线程2获得该锁,并且线程2在运行的过程中,此时线程1又想来获得该锁了,但线程2还没有释放该锁,所以线程1只能自旋等待.但虚拟机认为,由于线程1刚刚获得过该锁,那么虚拟机觉得线程1这次自旋也是很有可能能够再次成功获得该锁的,所以会延长线程1自旋的次数.
另外，如果对于某一个锁，一个线程自旋之后，很少成功获得该锁，那么以后这个线程要获取该锁时，是有可能直接忽略掉自旋过程，直接升级为重量级锁的，以免空循环等待浪费资源.
```

##### 重量级锁

轻量级锁膨胀之后,就升级为重量级锁了.重量级锁是依赖对象内部的monitor(监视器)锁来实现的,而monitor又依赖操作系统的MutexLock(互斥锁)来实现,所以重量级锁也被称为互斥锁.

当轻量级锁经过锁膨胀等步骤升级为重量级锁之后,它的Markword部分就数据大体如下:

| Bit fields      | 锁标志位 |
| --------------- | -------- |
| 指向Mutex的指针 | 10       |

###### 为什么说重量级锁开销大尼

主要是,当系统检查到锁是重量级锁之后,会把等待想要获得锁的线程进行阻塞,被阻塞的线程不会消耗cpu.但是阻塞或者唤醒一个线程时,都需要操作系统来帮忙,这就需要从用户态转换到内核态,而转换状态是需要消耗很多时间的,有可能比用户执行代码的时间还要长.

### **总结**

synchnorized关键字的锁的演变过程.也是从偏向锁,轻量级锁,再到重量级锁的过程.这个过程也知道了,假如我们一开始就知道某个同步代码块的竞争很激烈、很慢的话,那么我们一开始就应该使用重量级锁了,从而省掉一些锁转换的开销.